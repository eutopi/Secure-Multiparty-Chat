import sys, getopt
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto import Random
from base64 import b64encode
from Crypto.Util import Counter
from Crypto.Signature import PKCS1_PSS

statefile = 'rcvstate.txt'
encfile = ''
outputfile = ""
senderID = ''

try:
    opts, args = getopt.getopt(sys.argv[1:],'hi:o:')
except getopt.GetoptError:
    print("Usage: msg-ver.py -m <sender ID>")
    sys.exit(2)

for opt, arg in opts:
    if opt == '-h':
        print("Usage: msg-ver.py -m <sender ID>")
        sys.exit()
    # elif opt == '-m':
    #     senderName = arg

senderID = 'A'  #hardcode for now
encfile = 'output' + senderID
encfile  = encfile + '.txt'
# read the content of the encrytped file into msg
ifile = open(encfile, 'rb')
msg = ifile.read()
ifile.close()

# parse the message
header_length = 7                 # header is 7 bytes long
header = msg[0:header_length]
nonce = msg[header_length:header_length+8]   # nonce is AES.block_size bytes long
sig_length = 32                     # SHA256 hash is 32 bytes long
encrypted = msg[8+header_length:-sig_length]  # the encrypted part is the header and Payload
sig = msg[-sig_length:]
header_sender = header[0:1]         # sender is encoded on 1 byte 
header_length = header[1:3]         # msg length is encoded on 2 bytes 
header_sqn = header[3:7]            # msg sqn is encoded on 4 bytes

print("Message header:")
print("   - header_sender: " + header_sender.hex() 
# print("   - message length: " + header_length.hex() + " (" + str(int.from_bytes(header_length, byteorder='big')) + ")")
print("   - message snd sequence number: " + header_sqn.hex() + " (" + str(int.from_bytes(header_sqn, byteorder='big')) + ")")

# check the msg length
if len(msg) != int.from_bytes(header_length, byteorder='big'):
    print("Warning: Message length value in header is wrong!")
    print("Processing is continued nevertheless...")

# check the sequence number
print("Expecting sequence number " + str(rcvsqn + 1) + " or larger...")
sndsqn = int.from_bytes(header_sqn, byteorder='big')
if (sndsqn <= rcvsqn):
    print("Error: Message sequence number is too old!")
    print("Processing completed.")
    sys.exit(1)    
print("Sequence number verification is successful.")

# decrypt the encrypted part
print("Decryption is attempted...")
ctr = Counter.new(64, prefix=nonce, initial_value=0)

# create an AES-CTR cipher object
key = keystring.encode('utf-8')
ENC = AES.new(key, AES.MODE_CTR, counter=ctr)

# encrypt the header + payload
decrypted = ENC.decrypt(header + payload)

# parse decrypted into payload
msg_signed = decrypted

# create a SHA256 hash object and hash the content of the input file
h = SHA256.new()
h.update(msg_signed)

# read the signature from the signature file and convert to binary from base64
sigfile = 'setup/' + sender
sigfile = sigfile + '-key.pem'
sfile = open(signaturefile, 'rb')
sfile.readline() # reading the line '--- RSA PKCS1 PSS SIGNATURE ---'
signature = b64decode(sfile.readline())
sfile.close()

# verify the signature
verifier = PKCS1_PSS.new(groupkey)
result = verifier.verify(h, signature)

# print the result of the verification on the screen 
print('Done.')
if result:
        print('The signature is correct.')
        print('This is your message:')
        print(payload)
else:
        print('The signature is incorrect.')

# save state
state = "sndsqn: " + str(sndsqn + 1)
sndstatefile = 'sndstate' + sender + '.txt'
ofile = open(sndstatefile, 'wt')
ofile.write(state)
ofile.close()
print("Receiving state is saved.")
print("Processing completed.")
